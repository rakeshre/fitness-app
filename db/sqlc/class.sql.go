// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: class.sql

package db

import (
	"context"
	"time"
)

const createClass = `-- name: CreateClass :one
INSERT INTO class (
    instructorname,
    name,
    cost,
    scheduleid
)
VALUES
    ($1, $2, $3,$4) RETURNING id, instructorname, regstatus, name, classtype, cost, scheduleid
`

type CreateClassParams struct {
	Instructorname string         `json:"instructorname"`
	Name           string `json:"name"`
	Cost           int32          `json:"cost"`
	Scheduleid     int64          `json:"scheduleid"`
}

func (q *Queries) CreateClass(ctx context.Context, arg CreateClassParams) (Class, error) {
	row := q.db.QueryRowContext(ctx, createClass,
		arg.Instructorname,
		arg.Name,
		arg.Cost,
		arg.Scheduleid,
	)
	var i Class
	err := row.Scan(
		&i.ID,
		&i.Instructorname,
		&i.Regstatus,
		&i.Name,
		&i.Classtype,
		&i.Cost,
		&i.Scheduleid,
	)
	return i, err
}

const getAllClasses = `-- name: GetAllClasses :one
SELECT id, instructorname, regstatus, name, classtype, cost, scheduleid FROM class
`

func (q *Queries) GetAllClasses(ctx context.Context) (Class, error) {
	row := q.db.QueryRowContext(ctx, getAllClasses)
	var i Class
	err := row.Scan(
		&i.ID,
		&i.Instructorname,
		&i.Regstatus,
		&i.Name,
		&i.Classtype,
		&i.Cost,
		&i.Scheduleid,
	)
	return i, err
}

const getClass = `-- name: GetClass :one
SELECT id, instructorname, regstatus, name, classtype, cost, scheduleid FROM class
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetClass(ctx context.Context, id int64) (Class, error) {
	row := q.db.QueryRowContext(ctx, getClass, id)
	var i Class
	err := row.Scan(
		&i.ID,
		&i.Instructorname,
		&i.Regstatus,
		&i.Name,
		&i.Classtype,
		&i.Cost,
		&i.Scheduleid,
	)
	return i, err
}

const getClasses = `-- name: GetClasses :many
SELECT
    c.id AS class_id,
    c.name AS class_name,
    c.instructorname,
    c.cost,
    s.startdate,
    s.enddate,
    s.starttime,
    s.endtime,
    CASE
        WHEN cc.id IS NULL THEN 'Not Enrolled'
        ELSE 'Enrolled'
        END AS enrollment_status
FROM
    class c
        JOIN schedule s ON c.scheduleid = s.id
        LEFT JOIN classcatalogue cc ON c.id = cc.courseid AND cc.userid = $1
WHERE
        s.locationid = $2
  AND s.day = $3
ORDER BY
    s.starttime
`

type GetClassesParams struct {
	Userid     int64  `json:"userid"`
	Locationid int64  `json:"locationid"`
	Day        string `json:"day"`
}

type GetClassesRow struct {
	ClassID          int64          `json:"class_id"`
	ClassName        string `json:"class_name"`
	Instructorname   string         `json:"instructorname"`
	Cost             int32          `json:"cost"`
	Startdate        time.Time      `json:"startdate"`
	Enddate          time.Time      `json:"enddate"`
	Starttime        time.Time      `json:"starttime"`
	Endtime          time.Time      `json:"endtime"`
	EnrollmentStatus interface{}    `json:"enrollment_status"`
}

func (q *Queries) GetClasses(ctx context.Context, arg GetClassesParams) ([]GetClassesRow, error) {
	rows, err := q.db.QueryContext(ctx, getClasses, arg.Userid, arg.Locationid, arg.Day)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClassesRow{}
	for rows.Next() {
		var i GetClassesRow
		if err := rows.Scan(
			&i.ClassID,
			&i.ClassName,
			&i.Instructorname,
			&i.Cost,
			&i.Startdate,
			&i.Enddate,
			&i.Starttime,
			&i.Endtime,
			&i.EnrollmentStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClassesForEmployee = `-- name: GetClassesForEmployee :many
SELECT
    c.id AS class_id,
    c.name AS class_name,
    c.instructorname,
    c.cost,
    s.startdate,
    s.enddate,
    s.starttime,
    s.endtime
from class c
         JOIN schedule s ON c.scheduleid = s.id
WHERE
        s.locationid = $2 AND s.day = $1
ORDER BY
    s.starttime
`

type GetClassesForEmployeeParams struct {
	Day        string `json:"day"`
	Locationid int64  `json:"locationid"`
}

type GetClassesForEmployeeRow struct {
	ClassID        int64          `json:"class_id"`
	ClassName      string `json:"class_name"`
	Instructorname string         `json:"instructorname"`
	Cost           int32          `json:"cost"`
	Startdate      time.Time      `json:"startdate"`
	Enddate        time.Time      `json:"enddate"`
	Starttime      time.Time      `json:"starttime"`
	Endtime        time.Time      `json:"endtime"`
}

func (q *Queries) GetClassesForEmployee(ctx context.Context, arg GetClassesForEmployeeParams) ([]GetClassesForEmployeeRow, error) {
	rows, err := q.db.QueryContext(ctx, getClassesForEmployee, arg.Day, arg.Locationid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClassesForEmployeeRow{}
	for rows.Next() {
		var i GetClassesForEmployeeRow
		if err := rows.Scan(
			&i.ClassID,
			&i.ClassName,
			&i.Instructorname,
			&i.Cost,
			&i.Startdate,
			&i.Enddate,
			&i.Starttime,
			&i.Endtime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingClasses = `-- name: GetUpcomingClasses :many
WITH class_dates AS (
    SELECT
        c.id AS class_id,
        c.name AS class_name,
        s.starttime,
        s.endtime,
        s.day,
        GENERATE_SERIES(s.startdate, LEAST(s.enddate, NOW() + INTERVAL '7 days'), INTERVAL '1 day') AS class_date
    FROM
        classcatalogue cc
            JOIN class c ON cc.courseid = c.id
            JOIN schedule s ON c.scheduleid = s.id
    WHERE
            cc.userid = $1
)
SELECT
    class_id,
    class_name,
    class_date,
    starttime,
    endtime
FROM
    class_dates c
where
        TRIM(BOTH FROM TO_CHAR(class_date, 'Day')) = c.day and
    class_date BETWEEN NOW() AND NOW() + INTERVAL '7 days'
ORDER BY
    class_date, class_id
`

type GetUpcomingClassesRow struct {
	ClassID   int64          `json:"class_id"`
	ClassName string `json:"class_name"`
	ClassDate time.Time          `json:"class_date"`
	Starttime time.Time      `json:"starttime"`
	Endtime   time.Time      `json:"endtime"`
}

func (q *Queries) GetUpcomingClasses(ctx context.Context, userid int64) ([]GetUpcomingClassesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUpcomingClasses, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUpcomingClassesRow{}
	for rows.Next() {
		var i GetUpcomingClassesRow
		if err := rows.Scan(
			&i.ClassID,
			&i.ClassName,
			&i.ClassDate,
			&i.Starttime,
			&i.Endtime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
